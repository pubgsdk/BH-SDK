// Bloodhunt (1.X) SDK

#ifdef _MSC_VER
	#pragma pack(push, 0x8)
#endif

#include "TBP_UI_InventorySlot_classes.hpp"

namespace SDK
{
//---------------------------------------------------------------------------
//Functions
//---------------------------------------------------------------------------

// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ClearTooltipActions
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::ClearTooltipActions()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ClearTooltipActions"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ResetImageColourForArtifacts
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::ResetImageColourForArtifacts()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ResetImageColourForArtifacts"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateArtifact
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// int                            InStackCount                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::UpdateArtifact(int InStackCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateArtifact"));

	struct
	{
		int                            InStackCount;
	} params = {};

	params.InStackCount = InStackCount;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateCollectible
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// int                            InStackCount                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::UpdateCollectible(int InStackCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateCollectible"));

	struct
	{
		int                            InStackCount;
	} params = {};

	params.InStackCount = InStackCount;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateMod
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::UpdateMod()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateMod"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateConsumable
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::UpdateConsumable()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateConsumable"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateAmmo
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// class UTigerAmmoAsset*         InAmmoAsset                    (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::UpdateAmmo(class UTigerAmmoAsset* InAmmoAsset)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateAmmo"));

	struct
	{
		class UTigerAmmoAsset*         InAmmoAsset;
	} params = {};

	params.InAmmoAsset = InAmmoAsset;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.AddDynamicPingTooltipAction
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::AddDynamicPingTooltipAction()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.AddDynamicPingTooltipAction"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SwapWeaponEquippedOn
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::SwapWeaponEquippedOn()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SwapWeaponEquippedOn"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SendHasItemPing
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::SendHasItemPing()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SendHasItemPing"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SendWantItemPing
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::SendWantItemPing()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SendWantItemPing"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.IsValidAmmoItemForWeaponSlot
// (FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintEvent, FUNC_BlueprintPure, FUNC_Const)
// Parameters:
// class UTigerInventoryComponent* InInventoryComponent           (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// ETigerWeaponSlot               InWeaponSlot                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// class UTigerAmmoAsset*         InAmmoAsset                    (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// bool                           bCanUseAmmo                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)

void UTBP_UI_InventorySlot_C::IsValidAmmoItemForWeaponSlot(class UTigerInventoryComponent* InInventoryComponent, ETigerWeaponSlot InWeaponSlot, class UTigerAmmoAsset* InAmmoAsset, bool* bCanUseAmmo)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.IsValidAmmoItemForWeaponSlot"));

	struct
	{
		class UTigerInventoryComponent* InInventoryComponent;
		ETigerWeaponSlot               InWeaponSlot;
		class UTigerAmmoAsset*         InAmmoAsset;
		bool                           bCanUseAmmo;
	} params = {};

	params.InInventoryComponent = InInventoryComponent;
	params.InWeaponSlot = InWeaponSlot;
	params.InAmmoAsset = InAmmoAsset;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}

	if (bCanUseAmmo != nullptr)
		*bCanUseAmmo = params.bCanUseAmmo;
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetModUnavailableState
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::SetModUnavailableState()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetModUnavailableState"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetAmmoUnavailableState
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::SetAmmoUnavailableState()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetAmmoUnavailableState"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.CreateTooltipActions
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::CreateTooltipActions()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.CreateTooltipActions"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.GetRangedModInfo
// (FUNC_Public, FUNC_HasOutParms, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// class UTigerRangedModItemAsset* ModItemAsset                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// bool                           bIgnoreEquippedMod             (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)
// bool                           bIsModSlotEmpty                (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)
// bool                           bSupportsSwap                  (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)
// bool                           bHasHigherPriority             (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)

void UTBP_UI_InventorySlot_C::GetRangedModInfo(class UTigerRangedModItemAsset* ModItemAsset, bool bIgnoreEquippedMod, bool* bIsModSlotEmpty, bool* bSupportsSwap, bool* bHasHigherPriority)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.GetRangedModInfo"));

	struct
	{
		class UTigerRangedModItemAsset* ModItemAsset;
		bool                           bIgnoreEquippedMod;
		bool                           bIsModSlotEmpty;
		bool                           bSupportsSwap;
		bool                           bHasHigherPriority;
	} params = {};

	params.ModItemAsset = ModItemAsset;
	params.bIgnoreEquippedMod = bIgnoreEquippedMod;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}

	if (bIsModSlotEmpty != nullptr)
		*bIsModSlotEmpty = params.bIsModSlotEmpty;
	if (bSupportsSwap != nullptr)
		*bSupportsSwap = params.bSupportsSwap;
	if (bHasHigherPriority != nullptr)
		*bHasHigherPriority = params.bHasHigherPriority;
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ConstructTooltipWidget
// (FUNC_Event, FUNC_Public, FUNC_HasOutParms, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// class UTigerTooltipWidget*     ReturnValue                    (CPF_Parm, CPF_OutParm, CPF_ZeroConstructor, CPF_ReturnParm, CPF_InstancedReference, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

class UTigerTooltipWidget* UTBP_UI_InventorySlot_C::ConstructTooltipWidget()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ConstructTooltipWidget"));

	struct
	{
		class UTigerTooltipWidget*     ReturnValue;
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}

	return params.ReturnValue;
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UnequipMod
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::UnequipMod()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UnequipMod"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.EquipMod
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::EquipMod()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.EquipMod"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetModInWeapon
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// ETigerWeaponSlot               InWeaponSlot                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// class UTigerRangedModItemAsset* InModItemAsset                 (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// bool                           bInIsUnlocked                  (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)
// bool                           bInIsOnHud                     (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)

void UTBP_UI_InventorySlot_C::SetModInWeapon(ETigerWeaponSlot InWeaponSlot, class UTigerRangedModItemAsset* InModItemAsset, bool bInIsUnlocked, bool bInIsOnHud)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetModInWeapon"));

	struct
	{
		ETigerWeaponSlot               InWeaponSlot;
		class UTigerRangedModItemAsset* InModItemAsset;
		bool                           bInIsUnlocked;
		bool                           bInIsOnHud;
	} params = {};

	params.InWeaponSlot = InWeaponSlot;
	params.InModItemAsset = InModItemAsset;
	params.bInIsUnlocked = bInIsUnlocked;
	params.bInIsOnHud = bInIsOnHud;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UseConsumable
// (FUNC_Public, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::UseConsumable()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UseConsumable"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.DropPack
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// bool                           bWholeStack                    (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)

void UTBP_UI_InventorySlot_C::DropPack(bool bWholeStack)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.DropPack"));

	struct
	{
		bool                           bWholeStack;
	} params = {};

	params.bWholeStack = bWholeStack;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateInventorySlot
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// class UTigerItemAsset*         NewItemAsset                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)
// int                            ItemStackSize                  (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::UpdateInventorySlot(class UTigerItemAsset* NewItemAsset, int ItemStackSize)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.UpdateInventorySlot"));

	struct
	{
		class UTigerItemAsset*         NewItemAsset;
		int                            ItemStackSize;
	} params = {};

	params.NewItemAsset = NewItemAsset;
	params.ItemStackSize = ItemStackSize;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetStackCount
// (FUNC_Public, FUNC_HasDefaults, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// int                            InStackCount                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::SetStackCount(int InStackCount)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.SetStackCount"));

	struct
	{
		int                            InStackCount;
	} params = {};

	params.InStackCount = InStackCount;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.Construct
// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::Construct()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.Construct"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnDropSinglePack
// (FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::OnDropSinglePack()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnDropSinglePack"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnDropStack
// (FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::OnDropStack()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnDropStack"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.PreConstruct
// (FUNC_BlueprintCosmetic, FUNC_Event, FUNC_Public, FUNC_BlueprintEvent)
// Parameters:
// bool                           IsDesignTime                   (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor)

void UTBP_UI_InventorySlot_C::PreConstruct(bool IsDesignTime)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.PreConstruct"));

	struct
	{
		bool                           IsDesignTime;
	} params = {};

	params.IsDesignTime = IsDesignTime;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.BndEvt__TBP_UI_InventorySlot_Button_232_K2Node_ComponentBoundEvent_0_OnButtonHoverEvent__DelegateSignature
// (FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::BndEvt__TBP_UI_InventorySlot_Button_232_K2Node_ComponentBoundEvent_0_OnButtonHoverEvent__DelegateSignature()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.BndEvt__TBP_UI_InventorySlot_Button_232_K2Node_ComponentBoundEvent_0_OnButtonHoverEvent__DelegateSignature"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.BndEvt__TBP_UI_InventorySlot_IsHoveredCheck_K2Node_ComponentBoundEvent_1_OnButtonHoverEvent__DelegateSignature
// (FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::BndEvt__TBP_UI_InventorySlot_IsHoveredCheck_K2Node_ComponentBoundEvent_1_OnButtonHoverEvent__DelegateSignature()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.BndEvt__TBP_UI_InventorySlot_IsHoveredCheck_K2Node_ComponentBoundEvent_1_OnButtonHoverEvent__DelegateSignature"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.Select
// (FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::Select()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.Select"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.Unselect
// (FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::Unselect()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.Unselect"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.BndEvt__TBP_UI_InventorySlot_IsHoveredCheck_K2Node_ComponentBoundEvent_2_OnButtonClickedEvent__DelegateSignature
// (FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::BndEvt__TBP_UI_InventorySlot_IsHoveredCheck_K2Node_ComponentBoundEvent_2_OnButtonClickedEvent__DelegateSignature()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.BndEvt__TBP_UI_InventorySlot_IsHoveredCheck_K2Node_ComponentBoundEvent_2_OnButtonClickedEvent__DelegateSignature"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ExecuteUbergraph_TBP_UI_InventorySlot
// (FUNC_Final, FUNC_HasDefaults)
// Parameters:
// int                            EntryPoint                     (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::ExecuteUbergraph_TBP_UI_InventorySlot(int EntryPoint)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.ExecuteUbergraph_TBP_UI_InventorySlot"));

	struct
	{
		int                            EntryPoint;
	} params = {};

	params.EntryPoint = EntryPoint;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnHover__DelegateSignature
// (FUNC_Public, FUNC_Delegate, FUNC_BlueprintCallable, FUNC_BlueprintEvent)
// Parameters:
// class UTBP_UI_InventorySlot_C* InventorySlot                  (CPF_BlueprintVisible, CPF_BlueprintReadOnly, CPF_Parm, CPF_ZeroConstructor, CPF_InstancedReference, CPF_IsPlainOldData, CPF_NoDestructor, CPF_HasGetValueTypeHash)

void UTBP_UI_InventorySlot_C::OnHover__DelegateSignature(class UTBP_UI_InventorySlot_C* InventorySlot)
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnHover__DelegateSignature"));

	struct
	{
		class UTBP_UI_InventorySlot_C* InventorySlot;
	} params = {};

	params.InventorySlot = InventorySlot;

	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


// Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnUnhovered__DelegateSignature
// (FUNC_Public, FUNC_Delegate, FUNC_BlueprintCallable, FUNC_BlueprintEvent)

void UTBP_UI_InventorySlot_C::OnUnhovered__DelegateSignature()
{
	static UFunction* fn = UObject::FindObject<UFunction>(_xor_("Function TBP_UI_InventorySlot.TBP_UI_InventorySlot_C.OnUnhovered__DelegateSignature"));

	struct
	{
	} params = {};


	if (fn)
	{
		UObject::ProcessEvent(fn, &params);
	}
}


}

#ifdef _MSC_VER
	#pragma pack(pop)
#endif
